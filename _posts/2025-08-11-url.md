---
layout: single
title: java List를 기본형 배열로, 기본형 배열을 List로 변환 및 기본 타입을 리스트로 변환할 때의 함정!
permalink: /java/util/stream-Collectors/181844
categories: ["Java"]
tag: ["Java", "Coding Test"]
toc: true
---

## 문제 상황

프로그래머스의 [배열의 원소 삭제](https://school.programmers.co.kr/learn/courses/30/lessons/181844) 문제를 풀게 되었습니다.

평소 List에서 기본형 배열로 바꾸는 방법은 문제를 풀다가 알게되었고, 익숙해졌지만,  
기본형 배열에서 List으로 변경하는것은 이번이 처음이였고 수많은 에러를 마주하게 되었으며,  
그 이유와 원인을 분석하고 이를 통해 배운점이 많아 기록하고자 블로그를 쓰게 되었습니다.

```java
import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;

class Solution {
    public int[] solution(int[] arr, int[] delete_list) {
        List<Integer> arrList = new ArrayList(Arrays.asList(arr));

        for (int i = 0; i < delete_list.length; i++) {
            if(arrList.contains(delete_list[i])) {
                arrList.remove(delete_list[i]);
            }
        }

        int[] answer = arrList.stream().mapToInt(Integer::intValue).toArray();
        return answer;
    }
}
```

### 위 코드를 짰고 다음과 같은 에러를 마주하게 되었습니다.

> Exception in thread "main" java.lang.ClassCastException: class [I cannot be cast to class java.lang.Integer ([I and java.lang.Integer are in module java.base of loader 'bootstrap')

- 해석하자면 [I는 int[] 타입을 의미하는데 Integer는 Wrapper 클래스로 int[]와 Integer는 전혀 호환되지 않는다는 뜻....

- 발생한 원인의 코드는 `int[] answer = arrList.stream().mapToInt(Integer::intValue).toArray();`  
  리스트를 기본형 배열로 바꾸는 이 부분이였지만, 평소 List를 기본형 배열로 바꾸는것은 문제가 없다고 해서 이 코드는 문제가 없다고 판단했고 다른 부분을 보기 시작했습니다.

## 왜 이런 문제가 발생할까?

핵심 원인은 `Arrays.asList()`의 동작 방식 입니다.

- `Arrays.asList(T... a)`는 제네릭 T타입의 배열을 인자로 받습니다.
- 그런데 `int[]`는 원시 타입 배열이라 `T`가 `Integer`가 아니라 `int[]` 자체가 됩니다.
- 즉, `Arrays.asList(arr)`는
  - `List<int[]>`를 반환하는 거고 그 안에 요소는 `int[]` 하나 뿐입니다.
- 이상태에서 `List<Integer>`로 선언하면 컴파일 경고 없이 넘어가지만, 실행시 요소를 꺼내거나 스트림으로 변환할 때 int[]를 Integer로 캐스팅하려고 시도하다가 ClassCastException이 발생한것입니다.

### `List<Integer>`로 제네릭으로 타입을 명시했는데 왜 타입오류가 나지 않았을까?

그 이유는 바로 `new ArrayList()`에서 제네릭 타입을 안적었기 때문.... &rarr; `ArrayList`가 `Raw Type`으로 처리  
`Raw Type`은 제네릭 타입 검사를 컴파일 시점에 제대로 안합니다.(그래서 `List<int[]>`가 들어가도 컴파일러가 일단 넣어주고 넘어감....)  
`대신 런타임에서 캐스팅이 일어날 때 문제를 터진것`

## 잘못된 코드 예시

```java
// 제네릭을 명시하지 않은 코드(당장 오류는 나지 않지만 캐스팅시 오류가 남)
List<Integer> arrList = new ArrayList(Arrays.asList(arr));

// 제네릭을 명시한 코드(타입에러로 바로 알수 있음.)
List<Integer> arrList = new ArrayList<>(Arrays.asList(arr));

// 수정 가능한 List로 만들고 싶어....(굳이 new ArrayList<>()를 사용하지 않아도 된다.)
List<Integer> arrList = new ArrayList<>(Arrays.stream(arr).boxed().collect(Collectors.toList()));
```

## 올바른 변환 방법

### 기본형 배열에서 List로 변환

#### Java 8 방식 (권장, 호환성 높음)

```java
List<Integer> arrList = Arrays.stream(arr).boxed().collect(Collectors.toList()); // 가변 List
```

#### java 16+ 방식

```java
List<Integer> arrList = Arrays.stream(arr).boxed().toList(); // 하지만 불변 List라는거~
```

### List에서 기본형 배열로 변환

```java
int[] intArr = arrList.stream().mapToInt(Integer::intValue).toArray();;
```

## 정리

- Arrays.asList(int[])는 `List<int[]>`를 만든다. (원시 타입 배열 그대로)
- List<Integer>를 원하면 반드시 .boxed()를 거쳐야 한다.
- Java 8은 Collectors.toList(), Java 16+는 toList() 사용 가능.
- toList()는 불변 리스트이므로 수정 작업이 필요하면 Collectors.toList() 사용.
